{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Inferência por reamostragem e permutação\"\nauthor: \"Nazareno Andrade\"\ndate: \"16 de abril de 2016\"\noutput: \n  html_document:\n    theme: readable\n    fig_width: 7\n    toc: true\n    toc_float: true\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(ggplot2)\nlibrary(GGally)\nlibrary(dplyr)\ntheme_set(theme_bw())\n```\n\n# Significância\n\n## Exemplo 1: moeda\n\nJogamos 17 vezes, foi 2 vezes apenas cara. Temos evidência de que essa moeda é injusta? \n\nDecisão: o acontecido é improvável o suficiente numa moeda justa para que digamos que esta moeda é injusta?\n\nHipótese: a moeda é injusta. Hipótese nula: a moeda não é injusta. \n\nQuantas vezes conseguimos 15 ou mais coroas se jogamos a moeda muitas muitas vezes?\n\n```{r }\nobservado_coroas = 15\nlancamentos = 17\nprobabilidade_coroa = .5\n\nnumero_jogadas = 10000\n\n# Retorna o numero de vezes que um evento de \n# probabilidade p aconteceu em n tentativas\nrepete_experimento = function(p, n){\n  sorteios = runif(n, min = 0, max = 1)  \n  return(length(which(sorteios < p)))\n}\n\nnum_experimentos = 10000\nexperimentos = data_frame(i = 1:num_experimentos)\nexperimentos = experimentos %>% \n  rowwise() %>% \n  mutate(coroas = repete_experimento(probabilidade_coroa, lancamentos))\n\nggplot(experimentos, aes(x = coroas)) + \n  geom_histogram(binwidth = 1, colour = \"black\", fill = \"white\")\n\nquantas_aconteceram = length(which(experimentos$coroas >= observado_coroas))\nprobabilidade = quantas_aconteceram / num_experimentos\n\nquantas_aconteceram\nprobabilidade\n```\n\nEm `r quantas_aconteceram` de `r num_experimentos` rodadas observamos `r observado_coroas` ou mais coroas em `r lancamentos` lançamentos. A probabilidade de `r observado_coroas` acontecer aleatoriamente é portanto `r probabilidade`.\n\n## Exemplo 2: tratamento\n\nDados: \n\n```{r}\nexperimento = data_frame(tratamento= \"placebo\", melhora = c(54, 51, 58, 44, 55, 52, 42, 47, 58, 46))\nexperimento = rbind(experimento, data_frame(tratamento = \"droga\", melhora = c(54, 73, 53, 70, 73, 68, 52, 65, 65)))\nexperimento$tratamento = factor(experimento$tratamento)\nggpairs(experimento)\n\nView(experimento)\n\n# melhora observada como média: \nmedias = experimento %>% \n  group_by(tratamento) %>% \n  summarise(media = mean(melhora))\nView(medias)\nmelhora_media = medias[1, \"media\"] - medias[2, \"media\"]\nprint(paste(\"Melhora na média observada:\", melhora_media))\n```\n\nPergunta: houve uma melhora significativamente maior nos pacientes que usaram a droga? \n\nResposta: quantas vezes aconteceria se a relação entre tratamento e melhora fosse completamente aleatória? \n\n```{r}\n# Retorna a diferença nas médias entre o grupos de y\n# nos índices com valor de x igual a baseline após embaralhar x.\nrepete_experimento_de_diff = function(x, y, baseline){\n  embaralhado = x[sample(NROW(x))]\n  baseline_mean = mean(y[which(embaralhado == baseline)])\n  other_mean = mean(y[which(embaralhado != baseline)])\n  return(other_mean - baseline_mean)\n}\n\nnum_experimentos = 100\nexperimentos = data_frame(i = 1:num_experimentos)\nexperimentos = experimentos %>% \n  rowwise() %>% \n  mutate(diferenca = repete_experimento_de_diff(experimento$tratamento, experimento$melhora, \"placebo\"))\n\nggplot(experimentos, aes(x = diferenca))+ \n  geom_histogram(binwidth = 1, colour = \"darkblue\", fill = \"white\")\nsummary(experimentos)\n\nquantas_aconteceram = length(which(experimentos$diferenca >= melhora_media$media))\nprobabilidade = quantas_aconteceram / num_experimentos\n\nquantas_aconteceram\nprobabilidade\n```\n\nMesma lógica pode ser aplicada para a mediana. Para o 3o quartil, para o desvio padrão... \n(Mas não para tudo, infelizmente)\n\n# Relevância / importância\n\nA diferença é significativa. Mas ela é importante / relevante? \n\nPara responder, precisamos entender que diferença esperamos se repetirmos o experimento. Construir uma estimativa do intervalo onde esperamos que a diferença esteja em x% repetições. Isso é, um Intervalo de Confiança com uma confiança x.\n\nPara fazer isso, precisamos de várias amostras vindas da mesma população de pessoas que tomaram placebo e tomaram melhoras. E aqui é o pulo do gato: é possível estimar essa população usando a própria amostra. Isso se chama bootstrapping.\n\nImportante: Bootstrapping precisa de um pouco mais de dados do que temos neste exemplo. Aqui usamos os mesmos apenas pra simplificar a apresentação.\n\n```{r}\nrepeticoes = 1000 # pelo menos 1000, mas mais não faz mal.\n\nexp_com_bootstrap <- function(x, y){\n  boot_x <- sample(x, size = NROW(x), replace = TRUE) # aqui é o bootstrap\n  boot_y <- sample(y, size = NROW(y), replace = TRUE) # de novo!\n  return(mean(boot_x) - mean(boot_y))\n}\n\nexperimentos = data_frame(i = 1:repeticoes)\nexperimentos = experimentos %>% \n  rowwise() %>% \n  mutate(diferenca = exp_com_bootstrap(experimento[experimento$tratamento != \"placebo\",]$melhora, \n                                       experimento[experimento$tratamento == \"placebo\",]$melhora))\n\nggplot(experimentos, aes(x = diferenca)) + \n  geom_histogram(binwidth = 1, colour = \"darkorange\", fill = \"white\")\nsummary(experimentos)\n\n# IC com 95%: \nalpha = .1\nquantile(experimentos$diferenca, probs = c(alpha/2, 1 - alpha/2))\n\n# IC com 97,5%: \nalpha = .05\nquantile(experimentos$diferenca, probs = c(alpha/2, 1 - alpha/2))\n```\n\n# Sobre o uso de reamostragem (ressampling) e bootsraping\n\nEstimar o intervalo de confiança via bootstrap não é recomendado para amostras pequenas (n < 100). Nesses casos, testes de significância com permutação são mais adequados. Eles funcionam para n >= 3 de cada categoria.\n\nSignificância complementa o cálculo de ICs nessa abordagem. Por exemplo, pense no caso onde há uma observação no grupo 1 e uma no grupo 2. Há IC mas não há significância. \n\nNão use bootstrap para estimar o máximo, mínimo ou o n-ésimo maior/menor valor. Mas use para percentis.\n\nComo sempre, cuidado com outliers. \n\n# Com um pacote\n\n```{r}\n# install.packages(\"resample\")\nlibrary(resample)\n\npermutationTest2(experimento, mean(melhora), treatment = tratamento)\n\nb = bootstrap(experimento$melhora, mean)\nCI.percentile(b, probs = c(.025, .975))\n\nb2 = bootstrap2(experimento, mean(melhora), treatment = tratamento)\nCI.percentile(b2, probs = c(.025, .975))\n\nb2.median = bootstrap2(experimento, median(melhora), treatment = tratamento)\nCI.percentile(b2.median, probs = c(.025, .975))\n```\n\n\n# Estatísticas via reamostragem e bootstrapping vs. métodos clássicos\n\nUm exemplo com muitos dados:\n\n```{r}\nlastfm = read.csv(\"~/Rprojetos/fpcc2-master/02-inferencia/dados/experimento-lastfm.csv\")\nstr(lastfm)\n\nlastfm = select(lastfm, news, ecletic)\n\nlastfm %>% ggplot(aes(news)) + geom_histogram(binwidth = 10)\nlastfm %>% ggplot(aes(ecletic)) + geom_histogram(binwidth = 100)\n```\n\nImaginemos que essa é a população. \n\n## Método clássico\n\n```{r}\nsample(lastfm$news, 100) %>% mean()\n\n# Média de 200 amostras com n = 100\ndist_original = lastfm$news\nsample_size <- 50\nnum_samples <- 100\n\nsamples_means <- c()\nfor(i in seq(1, num_samples)){\n  a_sample <- sample(dist_original, sample_size)\n  samples_means[i] <- mean(a_sample)\n}\nggplot(data.frame(samples_means), aes(samples_means)) + geom_histogram()\n```\n\nÉ uma normal. E repare que a distribuição original era muito diferente disso. Esta é a *distribuição das médias das amostras*.\n\nTemos do Teorema do limite central que a distribuição de amostragem é uma distribuição normal com a média da população e um desvio padrão de $\\sigma = s / \\sqrt{n}$ (s é o desvio padrão da amostra, usado no lugar do desvio padrão da população, que não temos). Chamamos o desvio padrão da distribuição amostral de erro padrão (standard errror).\n\nO código para a versão forma fechada, que usa o teorema do limite central: \n\nEla funciona bem para amostras grandes e/ou distribuições que não sejam gravemente skewed / assimétricas.\n\nO experimento para explorar isso é o seguinte: se conhecemos a população, e repetimos 100 vezes o processo de a partir de uma amostra, estimar o intervalo de confiança da média com uma confiança de 95%,espermos que nossa estimativa inclua a média da população em 95 das 100 repetições. Ou mais. Se ela inclui menos, o erro está sendo maior que o esperado. \n\nUsando uma variável mais assimétrica (no nosso caso, news) e uma amostra não muito grande (eg. n = 50), observamos isso. \n\n```{r, fig.width=9}\nlibrary(\"Rmisc\", quietly = T)\nlibrary(dplyr)\n\npop_mean <- mean(dist_original)\n\nsample_cis <- data.frame(upper = c(), mean = c(), lower = c())\nfor(i in seq(1, num_samples)){\n  a_sample <- sample(dist_original, sample_size)\n  interval <- CI(a_sample, ci = 0.95)\n  sample_cis <- rbind(sample_cis, data.frame(mean = interval[\"mean\"], \n                                             lower = interval[\"lower\"], \n                                             upper = interval[\"upper\"]))\n}\nsample_cis <- sample_cis %>% \n  mutate(contains_pop_mean = (upper >= pop_mean & lower <= pop_mean)) \n\n# Demooooora...\nboot_cis <- data.frame(upper = c(), mean = c(), lower = c())\nfor(i in seq(1, num_samples)){\n  a_sample <- sample(dist_original, sample_size)\n  interval <- CI.percentile(bootstrap(a_sample, mean, R = 1000))\n  boot_cis <- rbind(boot_cis, data.frame(mean = mean(interval), \n                                         lower = interval[1], \n                                         upper = interval[2]))\n}\n\nboot_cis <- boot_cis %>% \n  mutate(contains_pop_mean = (upper >= pop_mean & lower <= pop_mean)) \n\nsample_cis %>% \n  ggplot(aes(x = 1:nrow(sample_cis), y = mean, colour = contains_pop_mean)) +\n  geom_point() + \n  geom_errorbar(aes(ymin = lower, ymax = upper)) + \n  geom_hline(aes(yintercept=mean(mean(dist_original))))\n\nboot_cis %>% \n  ggplot(aes(x = 1:nrow(sample_cis), y = mean, colour = contains_pop_mean)) +\n  geom_point() + \n  geom_errorbar(aes(ymin = lower, ymax = upper)) + \n  geom_hline(aes(yintercept=mean(mean(dist_original))))\n\n```\n\num applet (!) legal: [http://www.stat.berkeley.edu/~stark/Java/Html/Ci.htm]\n\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \n  stat_summary(fun.y = mean, geom = \"point\") + \n  stat_summary(fun.data = mean_cl_boot, geom = \"errorbar\", colour = \"blue\", width = 0.2)\n\n\n## Sobre sobreposições de barras de erro\n\n[http://scienceblogs.com/cognitivedaily/2008/07/31/most-researchers-dont-understa-1/] \n\n",
    "created" : 1463963053383.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1558860218",
    "id" : "D74A037D",
    "lastKnownWriteTime" : 1463975419,
    "last_content_update" : 1463975419438,
    "path" : "~/Rprojetos/fpcc2-master/02-inferencia/inferencia-1.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}